/*
 * Auto-generated by lean-bindgen from opaque_ptr.h
 * DO NOT EDIT â€” re-run the generator instead.
 */

#include <stdint.h>
#include <lean/lean.h>
#include "opaque_ptr.h"

/* Opaque type support for struct my_handle */
static void myHandleRef_finalizer(void *ptr) {
    /* TODO: call appropriate cleanup function for struct my_handle */
}

static lean_external_class *g_myHandleRef_class = NULL;

static lean_external_class *get_myHandleRef_class(void) {
    if (g_myHandleRef_class == NULL) {
        g_myHandleRef_class = lean_register_external_class(
            myHandleRef_finalizer, NULL);
    }
    return g_myHandleRef_class;
}

static inline lean_object *myHandleRef_box(struct my_handle *p) {
    return lean_alloc_external(get_myHandleRef_class(), (void *)p);
}

static inline struct my_handle *myHandleRef_unbox(lean_object *o) {
    return (struct my_handle *)lean_get_external_data(o);
}

lean_object* lean_opaque_ptr_my_handle_create(uint32_t flags, lean_object* w) {
    my_handle * result = my_handle_create((int)flags);
    lean_dec(w);
    return lean_io_result_mk_ok(myHandleRef_box(result));
}

lean_object* lean_opaque_ptr_my_handle_close(lean_object* h, lean_object* w) {
    struct my_handle *c_h = myHandleRef_unbox(h);
    uint32_t result = (uint32_t)my_handle_close(c_h);
    lean_dec(h);
    lean_dec(w);
    return lean_io_result_mk_ok(lean_box((size_t)result));
}
