/*
 * Auto-generated by lean-bindgen from mixed_api.h
 * DO NOT EDIT â€” re-run the generator instead.
 */

#include <stdint.h>
#include <lean/lean.h>
#include "mixed_api.h"

/* Opaque type support for struct db_conn */
static void dbConnRef_finalizer(void *ptr) {
    /* TODO: call appropriate cleanup function for struct db_conn */
}

static lean_external_class *g_dbConnRef_class = NULL;

static lean_external_class *get_dbConnRef_class(void) {
    if (g_dbConnRef_class == NULL) {
        g_dbConnRef_class = lean_register_external_class(
            dbConnRef_finalizer, NULL);
    }
    return g_dbConnRef_class;
}

static inline lean_object *dbConnRef_box(struct db_conn *p) {
    return lean_alloc_external(get_dbConnRef_class(), (void *)p);
}

static inline struct db_conn *dbConnRef_unbox(lean_object *o) {
    return (struct db_conn *)lean_get_external_data(o);
}

lean_object* lean_mixed_api_db_open(lean_object* path, lean_object* w) {
    const char *c_path = lean_string_cstr(path);
    db_conn * result = db_open(c_path);
    lean_dec(path);
    lean_dec(w);
    return lean_io_result_mk_ok(dbConnRef_box(result));
}

lean_object* lean_mixed_api_db_close(lean_object* conn, lean_object* w) {
    struct db_conn *c_conn = dbConnRef_unbox(conn);
    uint32_t result = (uint32_t)db_close(c_conn);
    lean_dec(conn);
    lean_dec(w);
    return lean_io_result_mk_ok(lean_box((size_t)result));
}

lean_object* lean_mixed_api_db_error(lean_object* conn, lean_object* w) {
    struct db_conn *c_conn = dbConnRef_unbox(conn);
    const char * result = db_error(c_conn);
    lean_dec(conn);
    lean_dec(w);
    return lean_io_result_mk_ok(lean_mk_string(result));
}

lean_object* lean_mixed_api_db_execute(lean_object* conn, lean_object* sql, lean_object* w) {
    struct db_conn *c_conn = dbConnRef_unbox(conn);
    const char *c_sql = lean_string_cstr(sql);
    uint32_t result = (uint32_t)db_execute(c_conn, c_sql);
    lean_dec(conn);
    lean_dec(sql);
    lean_dec(w);
    return lean_io_result_mk_ok(lean_box((size_t)result));
}
