"""
codegen.py — Generate Lean 4 binding files and C glue code.

This is the "printer" half of the transpiler.  It takes MappedFunc objects
(produced by the mapper) and emits two files:

  1. A .lean file with @[extern] opaque declarations
  2. A .c   file with thin wrapper functions that adapt types

Both files are designed to drop straight into a Lake project and build.
"""

from pathlib import Path
from typing import Sequence

from .mapper import MappedFunc


# ---------------------------------------------------------------------------
# Lean code generation
# ---------------------------------------------------------------------------


def gen_lean(
    module_name: str,
    funcs: Sequence[MappedFunc],
    header_name: str,
) -> str:
    """
    Generate the contents of a .lean file with @[extern] declarations.

    Parameters
    ----------
    module_name : Lean module name, e.g. "SimpleMath"
    funcs       : list of mapped functions to emit
    header_name : original header filename for the comment
    """
    lines: list[str] = []

    # Header comment
    lines.append(f"/-")
    lines.append(f"  Auto-generated by lean-bindgen from {header_name}")
    lines.append(f"  DO NOT EDIT — re-run the generator instead.")
    lines.append(f"-/")
    lines.append(f"")
    lines.append(f"namespace {module_name}")
    lines.append(f"")

    for fn in funcs:
        # Build the Lean type signature: param types → return type
        if fn.is_void:
            # Void C functions become IO Unit in Lean
            ret = "BaseIO Unit"
        else:
            ret = fn.return_lean_type

        param_sig = " → ".join(p.lean_type for p in fn.params)
        if param_sig and not fn.is_void:
            full_sig = f"{param_sig} → {ret}"
        elif param_sig and fn.is_void:
            full_sig = f"{param_sig} → {ret}"
        elif not param_sig and fn.is_void:
            full_sig = f"{ret}"
        else:
            full_sig = ret

        # Build the parameter list for the declaration
        param_decl = " ".join(f"({p.name} : {p.lean_type})" for p in fn.params)

        # Emit the declaration
        lines.append(f'@[extern "{fn.extern_symbol}"]')
        if fn.params:
            lines.append(f"opaque {fn.lean_name} {param_decl} : {ret}")
        else:
            lines.append(f"opaque {fn.lean_name} : {ret}")
        lines.append(f"")

    lines.append(f"end {module_name}")
    lines.append(f"")

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# C glue code generation
# ---------------------------------------------------------------------------


def gen_c_glue(
    funcs: Sequence[MappedFunc],
    header_name: str,
) -> str:
    """
    Generate the contents of a .c glue file.

    Each wrapper function:
      - Takes Lean-compatible types (e.g. uint32_t)
      - Casts to the original C types
      - Calls the real C function
      - Casts the result back to the Lean-compatible type
    """
    lines: list[str] = []

    # Header
    lines.append(f"/*")
    lines.append(f" * Auto-generated by lean-bindgen from {header_name}")
    lines.append(f" * DO NOT EDIT — re-run the generator instead.")
    lines.append(f" */")
    lines.append(f"")
    lines.append(f"#include <stdint.h>")
    lines.append(f'#include "{header_name}"')
    lines.append(f"")

    for fn in funcs:
        # Build parameter list for the wrapper
        ffi_params = ", ".join(f"{p.c_ffi_type} {p.name}" for p in fn.params)
        if not ffi_params:
            ffi_params = "void"

        # Build argument list for calling the original function
        call_args = ", ".join(f"({p.c_type}){p.name}" for p in fn.params)

        if fn.is_void:
            # void return — just call and return nothing
            lines.append(f"void {fn.extern_symbol}({ffi_params}) {{")
            lines.append(f"    {fn.c_name}({call_args});")
            lines.append(f"}}")
        else:
            lines.append(f"{fn.return_c_ffi_type} {fn.extern_symbol}({ffi_params}) {{")
            lines.append(
                f"    return ({fn.return_c_ffi_type}){fn.c_name}({call_args});"
            )
            lines.append(f"}}")

        lines.append(f"")

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# File writing
# ---------------------------------------------------------------------------


def write_output(
    content: str,
    out_path: str | Path,
) -> Path:
    """Write generated content to a file, creating directories as needed."""
    out_path = Path(out_path)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(content)
    return out_path
