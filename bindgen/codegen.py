"""
codegen.py — Generate Lean and C code from IR

This module generates Lean FFI bindings and C glue code from the IR.

Key features:
  - Uses IRContext + TypeMapper for type translations
  - Queries IR for type information
  - Extensible for future type categories (pointers, structs, etc.)

"""

from pathlib import Path
from typing import List, Union

from .ir import IRContext, Function, VoidType
from .type_mapper import TypeMapper, LeanTypeInfo


class CodeGenerator:
    """
    Generates Lean and C code from IR.

    Uses IRContext for structure and TypeMapper for type translations.
    """

    def __init__(self, ctx: IRContext, type_mapper: TypeMapper):
        self.ctx = ctx
        self.mapper = type_mapper

    def generate_lean(self) -> str:
        """
        Generate the contents of a .lean file with @[extern] declarations.

        Returns
        -------
        Complete .lean file content as a string
        """
        lines: List[str] = []

        # Header comment
        lines.append(f"/-")
        lines.append(
            f"  Auto-generated by lean-bindgen from {self.ctx.config.header_name}"
        )
        lines.append(f"  DO NOT EDIT — re-run the generator instead.")
        lines.append(f"-/")
        lines.append(f"")
        lines.append(f"namespace {self.ctx.config.module_name}")
        lines.append(f"")

        # Emit functions
        for func_id in self.ctx.get_supported_functions():
            func = self.ctx.get_function(func_id)
            if func:
                func_lines = self._generate_lean_function(func)
                lines.extend(func_lines)

        lines.append(f"end {self.ctx.config.module_name}")
        lines.append(f"")

        return "\n".join(lines)

    def _generate_lean_function(self, func: Function) -> List[str]:
        """Generate Lean declaration for a single function."""
        lines: List[str] = []

        # Map return type
        ret_mapping = self.mapper.map_type(func.return_type)
        if ret_mapping is None:
            # Shouldn't happen for supported functions, but be safe
            return lines

        ret_type = self.ctx.get_type(func.return_type)
        is_void = isinstance(ret_type.kind, VoidType) if ret_type else False

        # Determine return type signature
        if is_void:
            ret_sig = "BaseIO Unit"
        else:
            ret_sig = ret_mapping.lean_type

        # Build parameter declarations
        param_decls = []
        for param in func.params:
            param_mapping = self.mapper.map_type(param.type_id)
            if param_mapping is None:
                # Shouldn't happen, but be safe
                return lines
            param_decls.append(f"({param.name} : {param_mapping.lean_type})")

        # Build extern symbol
        extern_symbol = f"lean_{self.ctx.config.module_prefix}_{func.c_name}"

        # Emit the declaration
        lines.append(f'@[extern "{extern_symbol}"]')
        if param_decls:
            param_str = " ".join(param_decls)
            lines.append(f"opaque {func.c_name} {param_str} : {ret_sig}")
        else:
            lines.append(f"opaque {func.c_name} : {ret_sig}")
        lines.append(f"")

        return lines

    def generate_c_glue(self) -> str:
        """
        Generate the contents of a .c glue file.

        Each wrapper function:
          - Takes Lean-compatible types
          - Casts to original C types
          - Calls the real C function
          - Casts result back

        Returns
        -------
        Complete .c file content as a string
        """
        lines: List[str] = []

        # Header
        lines.append(f"/*")
        lines.append(
            f" * Auto-generated by lean-bindgen from {self.ctx.config.header_name}"
        )
        lines.append(f" * DO NOT EDIT — re-run the generator instead.")
        lines.append(f" */")
        lines.append(f"")
        lines.append(f"#include <stdint.h>")
        lines.append(f'#include "{self.ctx.config.header_name}"')
        lines.append(f"")

        # Emit wrapper functions
        for func_id in self.ctx.get_supported_functions():
            func = self.ctx.get_function(func_id)
            if func:
                func_lines = self._generate_c_function(func)
                lines.extend(func_lines)

        return "\n".join(lines)

    def _generate_c_function(self, func: Function) -> List[str]:
        """Generate C wrapper for a single function."""
        lines: List[str] = []

        # Map return type
        ret_mapping = self.mapper.map_type(func.return_type)
        if ret_mapping is None:
            return lines

        ret_type = self.ctx.get_type(func.return_type)
        is_void = isinstance(ret_type.kind, VoidType) if ret_type else False

        # Build parameter list for wrapper
        ffi_params = []
        for param in func.params:
            param_mapping = self.mapper.map_type(param.type_id)
            if param_mapping is None:
                return lines
            ffi_params.append(f"{param_mapping.c_ffi_type} {param.name}")

        ffi_param_str = ", ".join(ffi_params) if ffi_params else "void"

        # Build argument list for calling original function
        call_args = []
        for param in func.params:
            # Get original C type
            param_type = self.ctx.get_type(param.type_id)
            if param_type:
                call_args.append(f"({param_type.c_spelling}){param.name}")
            else:
                call_args.append(param.name)

        call_args_str = ", ".join(call_args)

        # Build extern symbol
        extern_symbol = f"lean_{self.ctx.config.module_prefix}_{func.c_name}"

        # Generate wrapper function
        if is_void:
            lines.append(f"void {extern_symbol}({ffi_param_str}) {{")
            lines.append(f"    {func.c_name}({call_args_str});")
            lines.append(f"}}")
        else:
            lines.append(
                f"{ret_mapping.c_ffi_type} {extern_symbol}({ffi_param_str}) {{"
            )
            lines.append(
                f"    return ({ret_mapping.c_ffi_type}){func.c_name}({call_args_str});"
            )
            lines.append(f"}}")

        lines.append(f"")

        return lines


def write_output(
    content: str,
    out_path: Union[str, Path],
) -> Path:
    """Write generated content to a file, creating directories as needed."""
    out_path = Path(out_path)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(content)
    return out_path
